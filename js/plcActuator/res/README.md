<div style = "font-family: 'Open Sans', sans-serif; font-size: 16px">

# ModuleActuator
<div style = "color: #555">
    <p align="center">
    <img src="./logo.png" width="400" title="hover text">
    </p>
</div>

## Лицензия
////

### Описание
<div style = "color: #555">

Модуль Actuator предназначен для обеспечения разработчиков функционалом для удобной и эффективной работы с актуаторами в рамках фреймворка Horizon Automated. 
Наделяет актуаторы полями и методами, которые покрывают типовые задачи идентификации и управления. Для этого модуль создает унифицированный интерфейс, разделяя объект актуатора на каналы. 
Каждый канал отвечает за отдельный аспект работы актуатора.
Данный подход обеспечивает единообразное взаимодействие с различными типами актуаторов, упрощая процесс учета и делегирования команд.

Одной из важнейших особенностей модуля является заложенный подход к созданию, организации и управлению наборами инструкций, которые выполняются актуатором в асинхронном режиме. В парадигме фреймворка Horizon Automated такие наборы инструкций именуются тасками (от англ. tasks). Модуль каждого актуатора имеет набор базовых тасков, а функционал рассматриваемой архитектуры позволяет расширять их коллекцию даже во время выполнения программы.   

Реализованный подход отличается классической работы с актуаторами набором механизмов, которые позволяют

1. Предотвращать вызов тасков, которые не могут начать выполняться в данный момент;
2. Отменять выполнение последнего вызванного таска;
3. Составлять цепочки с упорядоченным вызовом тасков.

Также заложенный в модуль функционал включает в себя поэтапную автоматическую обработку вх. сигнала на канал актуатора, что облегчает контроль над входным сигналом. Этот процесс включает в себя следующие этапы:
- Супрессия: входные данные подвергаются ограничению с использованием супрессорной функции. Это обеспечивает то, что значения с актуатора находятся в заданных пределах, что позволяет учесть границы работы актуатора или предотвратить определенные ошибки; 
- Трансформация линейной функцией: в случаях, когда величину, подаваемую на актуатор необходимо преобразовать (например, задать соответствие между физ.величиной и значением, которое должно быть подано на устройство), применяется линейная функция. Эта функция трансформирует значения согласно коэффициентам, которые задает пользователь;
- Проверка зоны измерений: значения с актуатора сверяются с зонами измерений, настраиваемые пользователем. Если значение выходит за пределы заданных зон, это активировать соответствующие реакции в виде коллбэков.

Больше об обработке данных в соответствующем [разделе](./README_DATA_REFINE.md#методы). 

Набор классов, обеспечивающих функционал датчика, можно условно поделить на следующие части: 
- Основная:
    - ветка классов [ClassBaseActuator](./README_ANCESTOR.md) и [ClassActuator](./README_MIDDLE.md), хранящих в себе поля и методы, общие для всех актуаторов;
    - класс [ClassChannelActuator](README_CHANNEL.md), служит интерфейсом для работы с отдельным каналом актуатора;
- Сервисная: 
    - [ClassSuppression и ClassTransform](./README_DATA_REFINE.md) реализует математико-логический аппарат для обработки и корректировки данных с датчика;
    - [ClassAlarms](./README_ALARMS.md) добавляет поддержку зон измерения и алармов (оповещений/сигналов тревоги);  
- Прикладная:
    - классы, наследующиеся от **ClassActuator** и реализующие его функционал для работы с конкретным датчиком. 

<div align='left'>
    <img src="./res/main-diagram.png" alt="Image not found">
</div>

</div>

### Примеры
#### Инициализация и запуск пьезо-зуммера
<div style = "color: #555">

```js
//Инициализация 
const bz = H.DeviceManager.Service.CreateDevice('bz')[0];
//Запуск работы зуммера с частотой 60% от максимальной
bz.On(0.6);
//Запуск с другой частотой через 1 сек
setTimeout(() => { 
    bz.On(0.4);    
}, 1500);
//Прекращение работы
setTimeout(() => { 
    bz.Off(); 
}, 3000);
```

</div>

#### Запуск цепочки тасков
<div style = "color: #555">

```js
//Вызов одного пика через основной, универсальный таск 
bz.RunTask('PlaySound', { freq: 300, numRep: 1, prop: 0.5, pulseDur: 800 });  
.then(
    // Вызов пика через таск, принимающий частоту и длину импульса 
    () => bz.RunTask('BeepOnce', 0.5, 800);
).then(
    // вызов двойного звукового сигнала
    () => bz.RunTask('BeepTwice', 0.8, 500);                   
).then(
    () => { console.log('Done!'); }
);
```

</div>

#### Добавление нового таска
<div style = "color: #555">

```js
//Объявление элементарного таска, запускающего зуммер на 3 сек
bz.AddTask('Beep3sec', (freq) => {
    this.On(freq);
    setTimeout(() => {
        this.Off();
        //Завершение выполнения таска
        this.ResolveTask(0);
    }, 3000);
});

bz.RunTask('Beep3sec', 0.5);
    .then(() => print(`Done after 3 sec!`));
```

</div>

#### Отмена выполнения таска после его вызова 
<div style = "color: #555">

```js
bz.RunTask('BeepTwice', 0.5, 1200);

setTimeout(() => {
    bz.CancelTask();
}, 1000);
```

</div>

#### Результат выполнения:

<div align='left'>
    <img src="" alt="Image not found">
</div>

### Зависимости
<div style = "color: #555">

- <mark style="background-color: lightblue">[ClassAppError](https://github.com/Konkery/ModuleAppError/blob/main/README.md)</mark>
</div>

</div>
    