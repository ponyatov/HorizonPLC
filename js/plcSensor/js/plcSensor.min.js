class ClassBaseSensor{constructor(_opts){if(this._Bus=_opts.bus,this._Pins=_opts.pins,this._Address=_opts.address,this._Id=_opts.id,this._Article=_opts.article,this._QuantityChannel=_opts.quantityChannel,this._Name=_opts.name,this._Type=_opts.type,this._ChannelNames=_opts.channelNames,_opts.precision&&(this._Precision=_opts.precision),_opts.repeatability&&(this._Repeatability=_opts.repeatability),this.CheckProps(),"hybrid"===this._Type.toLowerCase())try{this._SubChannels=_opts.subChannels.map(_subChId=>{let dev_id=_subChId.split("-")[0],chNum=_subChId.split("-")[1];return H.DeviceManager.Service.CreateDevice(dev_id)[chNum]})}catch(e){throw H.Logger.Service.Log({service:this._Id,level:"E",msg:"Error while parsing subChannels option"}),e}}CheckProps(){const isString=p=>"string"==typeof p,isStringNonEmpty=p=>"string"==typeof p&&p.length>0,isNumberPositive=p=>"number"==typeof p&&p>0,isOptionalString=p=>!p||isStringNonEmpty(p),isOptionalStringArray=p=>!p||Array.isArray(p)&&p.every(i=>isString(i));if(!isStringNonEmpty(this._Id))throw new Error("Invalid _Id");if(!isStringNonEmpty(this._Article))throw new Error("Invalid _Article");if(!isStringNonEmpty(this._Name))throw new Error("Invalid _Name");if(!isStringNonEmpty(this._Type))throw new Error("Invalid _Type");if(!isNumberPositive(this._QuantityChannel))throw new Error("Invalid _QuantityChannel");if(this._Bus instanceof I2C&&"number"!=typeof+this._Address)throw new Error("Address of i2c device is not provided")}GetInfo(){return{bus:this._Bus,pins:this._Pins,id:this._Id,article:this._Article,quantityChannel:this._QuantityChannel,name:this._Name,type:this._Type,channelNames:this._ChannelNames}}}class ClassSensor extends ClassBaseSensor{constructor(_opts){ClassBaseSensor.call(this,_opts),this._Channels=Array(this._QuantityChannel);for(let i=0;i<this._QuantityChannel;i++)_opts.channels=_opts.channels||[],this._Channels[i]=new ClassChannelSensor(this,i,_opts.channels[i])}get ID(){return this._Id}get CountChannels(){return this._Channels.filter(o=>o instanceof ClassChannelSensor).length}GetChannel(_num){const num=_num;return this._Channels[num]instanceof ClassChannelSensor?this._Channels[num]:null}Init(_opts){}Start(_chNum,_period,_opts){}Stop(_chNum){}ChangeFreq(_chNum,_period){}Configure(_chNum,_opts){}GetInfo(_chNum,_opts){}Reset(_chNum,_opts){}Calibrate(_chNum,_opts){}SetRepeatability(_chNum,_rep){}SetPrecision(_chNum,_pres){}Read(_reg){}Write(_reg,_val){}}class ClassChannelSensor{constructor(sensor,num,_opts){if(sensor._Channels[num]instanceof ClassChannelSensor)return sensor._Channels[num];let opts=_opts||{};this._Sensor=sensor,this._ValueBuffer={_depth:1,_rawVal:void 0,_arr:[],push:function(_val){for(this._rawVal=_val;this._arr.length>=this._depth;)this._arr.shift();this._arr.push(_val)}},this._Value=0,this._Status=0,this._ChangeThreshold=opts.changeThreshold,this._ChNum=num,this._Bypass=!1,this._DataUpdated=!1,this._DataWasRead=!1,this._TimeStamp,this._Transform=new ClassTransform(opts.transform),this._Suppression=new ClassSuppression(opts.suppression),this._Filter=new ClassFilter,this._Alarms=null,this.AvgCapacity=opts.avgCapacity||1}get Alarms(){return this._Alarms}get Suppression(){return this._Suppression}get Transform(){return this._Transform}get Filter(){return this._Filter}get ID(){return`${this._Sensor.ID}-${this._ChNum}`}get Name(){return`${this._Sensor.ID}-${this._ChannelNames[this._ChNum]}`}get ChName(){return this._Sensor._ChannelNames[this._ChNum]}get Status(){return this._Status}set Status(_s){"number"==typeof _s&&(this._Status=_s)}get ChangeThreshold(){return this._ChangeThreshold||0}set Bypass(_bp){this._Bypass=Boolean(_bp)}get Value(){if(this.Status)return this._DataUpdated=!1,this._DataWasRead||this._Bypass?this._Value:(this._Value=this._Filter.FilterArray(this._ValueBuffer._arr),this._DataWasRead=!0,this._Value)}set Value(_val){if(this._Bypass)this._Value=_val;else{let val=this._Suppression.SuppressValue(_val);val=this._Transform.TransformValue(val),this._ValueBuffer.push(val),this._DataUpdated=!0,this._DataWasRead=!1,this._Alarms&&this._Alarms.CheckZone(this.Value),this._TimeStamp=getTime()}}set AvgCapacity(_cap){_cap>1&&(this._ValueBuffer._depth=_cap)}EnableAlarms(){this._Alarms=new ClassAlarms(this)}ClearBuffer(){for(;this._ValueBuffer._arr.length>0;)this._ValueBuffer._arr.pop()}Start(_period,_opts){return!!this._Sensor.Start(this._ChNum,_period,_opts)&&this}Stop(){return!!this._Sensor.Stop(this._ChNum)&&this}ChangeFreq(_period){return this._Sensor.ChangeFreq(this._ChNum,_period)}Configure(_opts){return!!this._Sensor.Configure(this._ChNum,_opts)&&this}GetInfo(_opts){return this._Sensor.GetInfo(this._ChNum,_opts)}Reset(_opts){return this._Sensor.Reset(this._ChNum,_opts)}Calibrate(_opts){return this._Sensor.Calibrate(this._ChNum,_opts)}SetRepeatability(_rep){return this._Sensor.SetRepeatability(this._ChNum,_rep)}SetPrecision(_pres){return this._Sensor.SetPrecision(this._ChNum,_pres)}}class ClassFilter{constructor(_ch){this._Channel=_ch,this._FilterFunc=arr=>arr[arr.length-1]}FilterArray(arr){return this._FilterFunc(arr)}SetFunc(_func){if(!_func)return this._FilterFunc=arr=>arr[arr.length-1],!0;if("function"!=typeof _func)throw new Error("Not a function");return this._FilterFunc=_func,!0}}class ClassTransform{constructor(_ch,_opts){this._Channel=_ch,_opts?this.SetLinearFunc(_opts.k,_opts.b):this._TransformFunc=x=>x}SetFunc(_func){return _func?"function"==typeof _func&&(this._TransformFunc=_func,this._Channel):(this._TransformFunc=x=>x,!0)}SetLinearFunc(_k,_b){if("number"!=typeof _k||"number"!=typeof _b)throw new Error("k and b must be values");return this._TransformFunc=x=>_k*x+_b,this._Channel}TransformValue(val){return this._TransformFunc(val)}}class ClassSuppression{constructor(_ch,_opts){this._Channel=_ch,this._Low=-1/0,this._High=1/0,_opts&&this.SetLim(_opts.low,_opts.high)}SetLim(_limLow,_limHigh){if("number"!=typeof _limLow||"number"!=typeof _limHigh)throw new Error("Not a number");if(_limLow>=_limHigh)throw new Error("limLow value should be less than limHigh");return this._Low=_limLow,this._High=_limHigh,this._Channel}SuppressValue(_val){return E.clip(_val,this._Low,this._High)}}const indexes={redLow:0,yelLow:1,green:2,yelHigh:3,redHigh:4};class ClassAlarms{constructor(_channel){this._Channel=_channel,this.SetDefault()}SetDefault(){return this._Zones=[],this._Callbacks=new Array(5).fill((ch,z)=>{}),this._CurrZone="green",this._Channel}SetCallback(_ind,_cb){return"function"==typeof _cb&&(this._Callbacks[_ind]=_cb,!0)}SetZones(_opts){return!!_opts&&(!!this.CheckOpts(_opts)&&(_opts.yellow&&(this._Zones[indexes.yelLow]=_opts.yellow.low,this._Zones[indexes.yelHigh]=_opts.yellow.high,this.SetCallback(indexes.yelLow,_opts.yellow.cbLow),this.SetCallback(indexes.yelHigh,_opts.yellow.cbHigh)),_opts.red&&(this._Zones[indexes.redLow]=_opts.red.low,this._Zones[indexes.redHigh]=_opts.red.high,this.SetCallback(indexes.redLow,_opts.red.cbLow),this.SetCallback(indexes.redHigh,_opts.red.cbHigh)),_opts.green&&this.SetCallback(indexes.green,_opts.green.cb),this._Channel))}CheckOpts(opts){let yellow=opts.yellow,red=opts.red;if(yellow){if(yellow.low>=yellow.high||yellow.cbLow&&"function"!=typeof yellow.cbLow||yellow.cbHigh&&"function"!=typeof yellow.cbHigh)return!1;if(opts.red){if(yellow.low<red.low||yellow.high>red.high)return!1}else if(yellow.low<this._Zones[indexes.redLow]||yellow.high>this._Zones[indexes.redHigh])return!1}if(red){if(red.low>=red.high||red.cbLow&&"function"!=typeof red.cbLow||red.cbHigh&&"function"!=typeof red.cbHigh)return!1;if(!yellow&&(opts.red.low>this._Zones[indexes.yelLow]||opts.red.high<this._Zones[indexes.yelHigh]))return!1}return!0}CheckZone(val){let prevZone=this._CurrZone;this._CurrZone=val<this._Zones[indexes.redLow]?"redLow":val>this._Zones[indexes.redHigh]?"redHigh":val<this._Zones[indexes.yelLow]?"yelLow":val>this._Zones[indexes.yelHigh]?"yelHigh":"green",prevZone!==this._CurrZone&&this._Callbacks[indexes[this._CurrZone]](this._Channel,prevZone)}}exports=ClassSensor;