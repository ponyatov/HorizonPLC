const ClassActuator=require("plcActuator.min.js"),proportion=(x,in_min,in_max,out_min,out_max)=>(x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min;class ClassBuzzer extends ClassActuator{constructor(_opts){if(this.name="Buzzer",ClassActuator.call(this,_opts),this._MinFreq=0,this._MaxFreq=_opts.maxFreq||4e3,"number"!=typeof this._MaxFreq||"number"!=typeof this._MinFreq)throw new Error("Invalid range values");pinMode(this._Pins[0],"output",!0),this.InitTasks()}InitTasks(){this._Channels[0].AddTask("PlaySound",opts=>{["value","numRep","pulseDur","prop"].forEach(property=>{if("number"!=typeof opts[property]||opts[property]<0)throw new Error("Invalid args")}),opts.prop=E.clip(opts.prop,0,1),opts.pulseDur=E.clip(opts.pulseDur,0,2147483647);const value=opts.value;let Thi=opts.pulseDur,Tlo=Math.floor(opts.pulseDur*(1-opts.prop)/opts.prop);count=2*opts.numRep;let beep_flag=!0,beep_func=()=>{--count,count>0?(beep_flag?(this.SetValue(0),this._Interval=setTimeout(beep_func,Tlo)):(this.SetValue(value),this._Interval=setTimeout(beep_func,Thi)),beep_flag=!beep_flag):this.ResolveTask(0)};this.SetValue(value),this._Interval=setTimeout(beep_func,Thi)}),this._Channels[0].AddTask("BeepOnce",(function(_value,_dur){if(!Number.isInteger(_dur)||_dur<0)throw new Error("Invalid args");this.SetValue(_value),setTimeout(()=>{this.SetValue(0),this.ResolveTask(0)},_dur)})),this._Channels[0].AddTask("BeepTwice",(_val,_dur)=>{if(!Number.isInteger(_dur)||_dur<0)throw new Error("Invalid args");this.SetValue(_val),setTimeout(()=>{this.SetValue(0)},_dur),setTimeout(()=>{this.SetValue(_val)},2*_dur),setTimeout(()=>{this.SetValue(0),setTimeout(()=>{this.ResolveTask(0)},4*_dur)},3*_dur)})}SetValue(_chNum,_val){if("number"!=typeof _val)throw new Error;_val=E.clip(_val,0,1);let freq=proportion(_val,0,1,this._MinFreq,this._MaxFreq);return 0==_val?(analogWrite(this._Pins[0],0),this._Channels[0].Status=0):(analogWrite(this._Pins[0],.5,{freq:freq}),this._Channels[0].Status=1),!0}}exports=ClassBuzzer;