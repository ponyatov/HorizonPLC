const ClassSensor=require("plcSensor.min.js"),INPUT_PIN_MODES=["analog","input","input_pullup","input_pulldown","auto"];class ClassPortSensor extends ClassSensor{constructor(opts){if(ClassSensor.call(this,opts),this._QuantityChannel!==this._Pins.length)throw new Error("QuantityChannel must be equal to pins count");if(!Array.isArray(this._TypeInSignals)||this._TypeInSignals.length!==this._QuantityChannel)throw new Error("_TypeInSignals must be an array length of _QuantityChannel");opts.pinModes?this._Pins.forEach((_pin,i)=>{this.Configure(i,{mode:opts.pinModes[i]})}):this._Pins.forEach((_pin,i)=>{_pin.mode("output")})}Start(_chNum,_period,_opts){return this._Channels[_chNum].Status=1,this._Interval=setInterval(()=>{this._Channels.forEach((ch,i)=>{ch.Status&&(ch.Value=this.Read(this._Pins[i]))})},_period),!0}Stop(_chNum){return 0!==typeof this._Channels[_chNum].Status&&(this._Channels[_chNum].Status=0,this._Channels.map(ch=>ch.Status).find(s=>0!==s)||clearInterval(this._Interval),!0)}Read(port){let i=this._Pins.indexOf(port);return"analog"==this._TypeInSignals[i]?analogRead(port):digitalRead(port)}Configure(_chNum,_opts){return!!INPUT_PIN_MODES.includes(_opts.mode)&&(this._Pins[_chNum].mode(_opts.mode),!0)}GetInfo(_chNum){return Object.assign({mode:this._Pins[_chNum].getMode()},this._Pins[_chNum].getInfo())}}exports=ClassPortSensor;